%!TEX root = ../main.tex

\chapter {Theoretical Foundation \textasciitilde 15 sites}
\label {cha:theoretical foundation}
% Einleitung schreiben

\section{Unreachable Code \textasciitilde 1 site}
\emph{Unreachable Code} specifies a piece of source-code within a function, which can not be executed due to no feasible path.
There are two categories of unreachable code:
\begin{itemize}
	\item No path to the given piece of source-code exists, which is created by unconditional jumps, even tough other instructions would follow. 
	Many compilers already check for this type of error.
	\item Infeasible path conditions are the more common type found in programs and harder to detect. The complete environment has to be known during analysis (state of variables) and be taken into account. 
\end{itemize}

Fixing this type of error may be hard, since it indicates faulty logic created by accident. 

\subsection{Difference to Dead Code \textasciitilde 1/3 site}
\emph{Dead Code} is that part of the source-code, which may be reachable, is not used any further. It is sometimes also referred to \emph{Unused Code}
(e.g. variables, classes or functions and methods, but also files \cite{Boomsma_2012}).
\emph{Dead Code} and \emph{Unreachable Code} are often confused. Some standards even describe \emph{Unreachable Code} as a subset of \emph{Dead Code} \cite{CWECWE561Dead}.
Declaring \emph{Unreachable Code} as \emph{Dead Code} is debatable, since \emph{Unreachable Code} is dead basically. The \emph{dead} part in this case would be an \emph{Instruction Block} within the \emph{Control-flow Graph}.
Removing \emph{Dead Code} is an easier task compared to other forms of defects since the unused part may simply be deleted.
\subsection{Difference to Unnecessary Code \textasciitilde 1/3 site}
\emph{Unnecessary Code} describes source-code, in which no stake holder has interest in. This may either be by accidental re-implementations of a feature or changes of interest of feature implementations, which have not been deleted\cite{Haas_2020}.


\section{Kemro-IEC 61131-3 \textasciitilde 3 sites}
% TODO: Sprachfeatures beschreiben
% https://webstore.iec.ch/preview/info_iec61131-3%7Bed3.0%7Db.pdf -> sind actually min 2 sprachen
\emph{IEC 61131-3} is a standard which specifies syntax and semantics for programmable controllers. 
% Keine Dynamische Allokierung --> Alles vor Laufzeit
% Kein Polymorphismus
% Predictable Schedule
% sehr async (events)
% 4 sprachen - 2 textuelle + 2 graphische
% Projects
% - FU, AlgorithmBlock, Function
% Variables - auch svs etc.
% Statements & Instructions
% Pointer Arithmetik
% 
 
\section{Abstract Syntax Tree \textasciitilde 1 site}
% Aufbau
% Unterschied zu normalem syntax tree
% 
\section{Controlflow Graph \textasciitilde 1 sites}
% Instruction Blocks
% Kanten
% Instructions
% Verwendungszwecke
\section{Single Static Assignment Form \textasciitilde 1 sites}
% Representation der Instruktionen, Variablen, etc.
% Phi Funktion
% Vorteile
% Verwendungszweck

\section{Constant Propagation \textasciitilde 1 sites}
% 
\section{Types of procedural Analysis}
% Procedures are evaluated either \emph{Inter-} or \emph{Intra-proecedural}. 

During analysis of \emph{Functions} or \emph{Procedures} the calling of other \emph{Functions} and \emph{Procedures} may be taken into account to enable more detailed information of programs.


\begin{itemize}
	\item \emph{Intraprocedural Analysis} does not take \emph{Function-}/Procedure-calls into account. 
	\item \emph{Interprocedural Analysis} takes \emph{Function-}/Procedure-calls and their concrete return values into account.
\end{itemize}


\section{Satisfiable Modulo Theory \textasciitilde 3 sites}
% Geschichte
% SAT-Solver
% Verwendungszwecke
\subsection{Satisfiability Prover \textasciitilde 1 site}
% Übersicht verschiedener Implementierungen
% Standardisierung erwähnen (SMT-Lib2)
\subsection{SMT-LIB \textasciitilde 1 sites}
SMT-LIB offers standardization to implementing SMT-Solvers by defining a common input- and output format, providing descriptions of background theories and more \cite{cokSMTLIBv2LanguageTools}. % https://smtlib.cs.uiowa.edu/
By using the same input and output format SMT-Solvers may be exchanged at any time. 
This format is LISP-like and shares the same characteristics and being a functional programming language. 
For example mutations are not permitted and there is no possiblity of using traditional loops (which may be replaced by recursion).
Usually a SMT-LIB programm begins with declaring functions. Variables are also represented as functions. 
Afterwards the given Boolean Expression is formulated. Since there is no direct way to initialize a variable with a value, it has to be done by using the equality function. 
The last part contains an instruction for the SMT-Solver to check the satisfiability. 
Since solvers are implemented using backtracking it is also possible to gain the calculated values which fit the given expression, if it is satisfiable. 
SMT-Solvers may also implement the simplification of a given expression.
% SMT-Lib2 (LISP) präsentieren