%!TEX root = ../main.tex

\chapter{State of the Art}
\label{cha:state of the art}

Analyzing and refactoring code is a central part of software development. Naturally this process can be automated to some degree using various static code analysis tools. 
Some of these tools are applied at different stages during development ranging from compiler to static code analysis in the cloud.
In this chapter multiple static code analysis tools will be presented, ranging in quality for detecting bugs (with a focus on unreachable code).
The accuracy for finding unreachable code increases with each tool presented. 
The examples are provided in the Java language beginning with the Java compiler itself, which verifies the correctness and validity of written source code before compilation. 
The Java compiler also includes a linter, which does not do any additional checks regarding unreachable code. 


One of the most important tools a programmer uses is arguably the Integrated Development Environment (IDE), which usually includes a code inspector for preventing bugs as the code is written. 
The most popular Java IDEs have been Eclipse \cite{incCommunityOpenInnovation} and IntelliJ \cite{IntelliJIDEACapable}. 
Possibly both may be improved by installing additional plugins for checking code.


Sonarqube \cite{sonarqube} is a static code analysis tool hosted in the cloud and usually is part of a continous integration pipeline. It offers a wide variety of checks including a more in depth unreachable code analysis.


Some instances of unreachable code may not be found using the mentioned before. For a more advanced approach statements have to be evaluated. Infeasible path conditions may be found by using a mathematical prover or SMT-Solver.
\clearpage
\pagebreak
\section{Java Compiler}
\label{sec:Java compiler}
% Javac also used by IDEs. 

The Java compiler (javac) performs checks regarding unreachable code and strictly results in a compile time error. 
In the official documentation \cite{Chapter14Blocks} unreachable code is defined as follows:
\begin{quote}
\label{quote:Java unreachable definition}
This section is devoted to a precise explanation of the word "reachable." 
The idea is that there must be some possible execution path from the beginning of the constructor, method, instance initializer, or static initializer that contains the statement to the statement itself. The analysis takes into account the structure of statements. Except for the special treatment of while, do, and for statements whose condition expression has the constant value true, the values of expressions are not taken into account in the flow analysis.
\end{quote}

Since values are not considered during this analysis, it is impossible to detect infeasible code as described in Listing \ref{code:Java infeasible undetected}.
 Loops are the exception here, but only conditions containing literal boolean values will be checked and may result in a compile time error as demonstrated by Listing \ref{code:Java loop unreachable}. The rationale behind not considering the values of variables and even constants is to use them as flags (see Listing \ref{code:Java flags}).


Unexpected return statements turn the following statements unreachable. As shown in Listing \ref{code:Java unexpected return} and mentioned before, conditions of if-then-else blocks are not evaluated, even if they contain only (boolean) literals. But again this does not apply to loops.


Unexpected break statements turn the following statements within the current scope of the loop unreachable as shown in Listing \ref{code:Java unexpected break}.


\begin{program}[h!]
	\begin{JavaCode}
void testUnreachableWhile() {
	int x = 3;
	while(false || false && true) x = 10; // compile time error
}

void testUnreachableWhileNoError() {
	int x = 3;
	while(false || false && true || x == 4) x = 10; // No error
}

void testUnreachableWhileBoolean() {
	int x = 3;
	boolean y = false;
	while(false || false && true || y) x = 10; // No error
}\end{JavaCode}
	\caption{The Java compiler evaluates conditions of loops, if, and only if, they contain literal boolean values only. Even tough the second method is definitly unreachable, no error will be reported. The same applies to the third method. Even tough the value is always the same, no error will be reported.}
	\label{code:Java loop unreachable}
\end{program}

\begin{program}[h!]
	\begin{JavaCode}
void testSimpleIf() {
	int x = 3;
	if(false) x = 10; // No error
}\end{JavaCode}
	\caption{Simple if-then-else statements do not evaluate the condition at all in contrast to loops seen in figure \ref{code:Java loop unreachable}.}
	\label{code:Java infeasible undetected}
\end{program}

\begin{program}[h!]
	\begin{JavaCode}
void testFlag() {
	int x = 3;
	final boolean DEBUG = false;
	if(DEBUG) x = 10; // No error
}\end{JavaCode}
	\caption{The rationale behind not even considering constant values is the usage of flags.}
	\label{code:Java flags}
\end{program}

\begin{program}[h!]
	\begin{JavaCode}
void testSystemExit() {
	System.exit(0);
	int x = 0; // no error - System.exit is not handled like a return statement
}

void testAlwaysReturn() {
	if(true) return;
	int x = 0; // no error - condition is not checked
}

void testReturn() {
	return;
	int i = 3; // Compilation error - unreachable statement
}

void testReturnInAllBranches() {
	boolean x = true;
	if(x) return;
	else return;
	x = false; // Compilation error - unreachable statement
}

void testReturnInWhile() {
	while(true) {
		return;
	}
	int i = 34; // Compilation error - unreachable statement
}\end{JavaCode}
	\caption{Examples of unreachable code due to unexpected return statements. Interestingly System.exit(), a statement that does terminate the program, is not handled like a return statement. As stated before, conditions of if-then-else blocks are not evaluated and therefore do not report an error, but conditions in loops are the exception again. }
	\label{code:Java unexpected return}
\end{program}

\begin{program}[h!]
	\begin{JavaCode}
void testBreak() {
	while(true) {
		int i = 3;
		break; 
		i++; // Compilation error - unreachable statement
	}
}

void testBreak2() {
	while(true) {
		int i = 3;
		if(true) break; 
		i++; // no error - condition is not checked
	}
}\end{JavaCode}
	\caption{Examples of unreachable code due to unexpected break statements.}
	\label{code:Java unexpected break}
\end{program}

Regarding unreachable code the Java compiler performs a data-flow analysis. The liveness of each statement will be analyzed by the "AliveAnalyzer" class in Flow.Java. The implemented AST-model makes use of the visitor pattern \cite{gammaDesignPatternsElements}. During analysis each node will be visited and checked according to definition \ref{quote:Java unreachable definition}.


\clearpage
\pagebreak
\section{Integrated Development Environments}
\label{sec:intelliJ}
Integrated Development Environments (IDE) are used by almost every software developer daily and an integral tool for creating correct and safe code.
In comparison to simple text editors IDEs only support a few select programming languages. Generally, they provide better support and usually do contain some sort of static code analysis to assist a developer writing good code. 
Depending on the IDE, static code analysis can be configured to be more or less strict. 
When the IDE contains an extensive plugin system, then custom-made analysis tools may be used for a possibly even more precise method to find potential bugs.


Regarding unreachable code the following IDEs were analyzed:
\begin{itemize}
	\item \emph{Eclipse} \cite{incCommunityOpenInnovation} is an IDE primarily focused on developing Java projects. A basic, configurable inspection tool is integrated. Additional to the checks by the Java compiler, conditions in if-then-else expressions are also evaluated and checked by default. When values of variables are known, then they will be considered in the analysis as shown in Listing \ref{code:Java eclipse intelij always true or false}. Generally, the inspector is very basic regarding unreachable code detection. As shown in Listing \ref{code:Java eclipse fail to find this} its inspector does not even consider the same condition in an if/else-if block. Other datatypes (e.g., Integer) are also taken into account. Besides that Eclipse is extensible and many additional tools for more sophisticated analysis exist.
	\item \emph{IntelliJ Idea} \cite{IntelliJIDEACapable} is an IDE used for developing projects in various popular programming languages (e.g., Java, C\#, Python, JavaScript). For the Java language, a code inspector can be configured to find different categories of errors. By default two important rules are activated to deliver warnings: 
	\begin{itemize}
		\item \emph{Constant conditional expressions}, which do not only check for boolean literals in conditions, but also take values of variables, in case they always have the same value, and even other data types (e.g., Integer) into account as shown in Listing \ref{code:Java eclipse intelij always true or false}
		\item \emph{Duplicate Condition} that have already been checked. Even though this may sometimes be intended, in most cases they are overlooked or may even not be reached, when the method terminates in the branch followed by the former condition as shown in Listing \ref{code:Java intelij duplicate conditions}. 
	\end{itemize}
	IntelliJ also provides a plugin system and therefore the possibility integrating an even better analysis is given.
\end{itemize}

% Beispiele fÃ¼r eclipse + IntelliJ

\begin{program}[h!]
	\begin{JavaCode}
void testAlwaysTrueCondition() {
	if(true) return; // Warning: Condition is always true
	int i = 3;
}

void testAlwaysFalse() {
	boolean x = true;
	boolean y = false;
	if(x && y) int i = 3; // Warning: Condition is always false
}

void testUnreachableWhile() {
	int x = 3;
	while(x > 4) x = 10; // Warning: Condition is always false
}\end{JavaCode}
	\caption{Internal code inspection tools of the IDEs \emph{Eclipse} and \emph{IntelliJ Idea} are capable of detecting conditions, which always evaluate to true or false.}
	\label{code:Java eclipse intelij always true or false}
\end{program}

\begin{program}[h!]
	\begin{JavaCode}
void testCondAlreadyChecked(boolean x) {
	int y = 0;
	if(x) {
		y = 3;
	} else if(x) { // Condition already checked before
		y = 4;
	}
	y++;
}\end{JavaCode}
\caption{Eclipse does not even check for duplicate conditions within the same if/else-if block. In contrast IntelliJ does find this issue.}
\label{code:Java eclipse fail to find this}
\end{program}

\begin{program}[h!]
	\begin{JavaCode}
void duplicateConditions(int s_operationHour, int m_operationHour) {
	if(s_operationHour != m_operationHour) { // Warning: Duplicate condition
		m_operationHour = s_operationHour;
		if (s_operationHour == 0) {
			foo();        
		}
		return;
	}
	if(s_operationHour == 0) {
		m_operationHour = 0;
	} else {
		// Unreachable, since the condition was checked already and returned
		if(s_operationHour != m_operationHour) { // Warning: Duplicate condition
			s_operationHour = m_operationHour;
		}
	}
}\end{JavaCode}
	\caption{Even tough these warnings do not hint to the unreachable code directly, they show a code smell prone to errors. In this particular case the else branch of the second if-then-else block cannot be reached, since the method already returned. In case one of the variables used in the second said condition, this error would not occur! Removing the return statement in line 7 removes this type of problem, but the second condition would always evaluate to false. }
	\label{code:Java intelij duplicate conditions}
\end{program}
\newpage
\section{Sonarqube \& Sonarlint} % Could be interessting since it is very strict and performs more advanced analysis
\label{sec:sonar}
\emph{Sonarqube} \cite{sonarqube} and \emph{Sonarlint} \cite{SonarLintFixIssues} are products created by \emph{Sonarsource} \cite{CodeQualityCode}. Sonarqube is a static code analysis solution used in conjunction with a build server.
Commonly this analysis is either triggered after pushing commits, scheduled at certain times of the day or a combination of both.
Sonarqube supports a multitude of programming languages ranging from Java to Python and even COBOL. Another language may be supported in form of a plugin.


Sonarlint is available for some IDEs (including Eclipse and IntelliJ) in form of a plugin to provide immediate feedback. Note that this plugin only covers a subset of functionalities of sonarqube, but still provides better support than many internal inspectors built into IDEs.

\newpage

Using the same example as before (seen in Listing \ref{code:Java intelij duplicate conditions}) Sonarqube detects that this expression always evaluates to false, which provides better information than the internal code inspector of IntelliJ, as demonstrated in Listing \ref{code:Java sonarqube duplicate conditions}. The example shown in Listing \ref{code:Java sonarqube hard example} cannot be detected. It appears that mutation in loops are not evaluated and will therefore not deliver any error. This type of error may only be detected by evaluating each statement.


\begin{program}[h!]
	\begin{JavaCode}
void duplicateConditions(int s_operationHour, int m_operationHour) {
	if(s_operationHour != m_operationHour) {
		m_operationHour = s_operationHour;
		if (s_operationHour == 0) {
			foo();        
		}
		return;
	}
	if(s_operationHour == 0) {
		m_operationHour = 0;
	} else {
		if(s_operationHour != m_operationHour) { // SonarLint: Change this Condition so it does not always evaluate false
			s_operationHour = m_operationHour;
		}
	}
}\end{JavaCode}
	\caption{The same example as seen in Listing \ref{code:Java intelij duplicate conditions}, but sonarqube reports the problem correctly. }
	\label{code:Java sonarqube duplicate conditions}
\end{program}

\begin{program}[h!]
	\begin{JavaCode}
void testLoop(boolean pred) {
	int x = 1;
	do {
		boolean b = x != 1;
		// b can never be true, this will possibly result in an infinite loop.
		if(b) {
			pred = false;
		}
	} while(pred);
}

void testDeadCode() {
	int i, j;
	i = 3;
	for(j = 1; j < i; ++j) {
		// ...
	}
	// i must be equal to j
	if(i != j) { 
		// ...
	}
}\end{JavaCode}
	\caption{Neither the internal code inspector nor sonarlint/-qube were able to catch these errors. }
	\label{code:Java sonarqube hard example}
\end{program}

\clearpage
\section{Joogie}
\label{sec:sca paper}
% TODO: Verbessern und Beispiele hinzufÃ¼gen
Joogie \cite{arltJoogieInfeasibleCode2012, arltJoogieJavaJimple2013} identifies infeasible code of any Java-project using a verification system. 
At first the source code will be transformed into a 3-address intermediate representation of Java bytecode using the Soot framework. Consequently only 15 kinds of statements are considered. 

Afterwards the Java bytecode is transformed into the Boogie language, which is an imperative intermediate verification language for analyzing high-level programming languages.
During the translation the memory model has to be preserved. The heap is represented by a two-dimensional array. The first index refers to the object's address and the second to the field of the object.

Loops are unwound into three unwindings: the first and last iteration, as well as an abstract unwinding of the rest.
The result is a program containing no loops. Every assignment inside the loop replaces the value into non-determined values. Therefore loops are not fully evaluated.


Methods are checked in an intraprocedural manner. Therefore variables that may change become non-deterministic. 


Afterwards the Boogie program will be called by the verifier. 
The foundation of the verifier is the SMT-solver Z3.



When infeasible code is encountered, the java bytecode will be transformed back into Java and a violation will be reported.


This tool was tested on 4 bigger open source software projects including ArgoUML, TerpWord, Rachota and Freemind, and only few false warnings were reported.
The time needed for analysis was tolerable, since usually only small code fragments have to be analyzed instead of the whole project.

This tool is as capable as Sonarqube \ref{sec:sonar} in finding unreachable code.

